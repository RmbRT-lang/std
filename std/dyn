(/rl/)

INCLUDE 'std/heap'

::std [T:TYPE] Dyn
{
	Ptr: T! *;

	{}: Ptr(NULL);
	{NULL}: Ptr(NULL);
	{BARE} ();

	{&&m}: Ptr(m.release());

	:gc{p: T! *}: Ptr(p);

	[Args...: TYPE]
	:a{args: Args!&&...}:
		Ptr(heap::[T]new(<Args!&&>(args)...));
	[Arg: TYPE]
	:if{if: BOOL, then: Arg!&&}:
		Ptr := if ?? heap::[T]new(<Arg!&&>(then)) : NULL;

	[Args...: TYPE]
	:make{args: Args!&&...}
		(<<<T>>>(<Args!&&>(args)...));
	[Args...: TYPE]
	:gcmake{args: Args!&&...}:
		Ptr := <<<T>>>(<Args!&&>(args)...);


	[Args...: TYPE]
	:make_if{if: BOOL, args: Args!&&...}:
		Ptr := NOINIT
	{
		IF(if)
			THIS.{<<<T>>>(<Args!&&>(args)...)};
		ELSE
			Ptr := NULL;
	}

	[Args...: TYPE]
	:gcmake_if{if: BOOL, args: Args!&&...}:
		Ptr := if ?? <<<T>>>(<Args!&&>(args)...) : NULL;

	[V:TYPE]
	:dup{v: V!&&}:
		Ptr(heap::[V]new(<V!&&>(v)));

	[V:TYPE] {m: V!-Dyn! &&}
	{
		IF(m)
		{
			// Try to convert into our pointer type, this might fail.
			Ptr := <<T \>>(m!);
			m.{};
		}
		ELSE
			Ptr := NULL;
	}

	# <T! \> INLINE := Ptr;
	# *THIS T! & INLINE := *Ptr;
	# THIS! T! * INLINE := Ptr;

	release() T! *
	{
		p ::= Ptr;
		Ptr := NULL;
		= p;
	}

	[Args...: TYPE]
	ensure(args: Args!&&...) T! * INLINE
	{
		IF(!Ptr)
			Ptr := heap::[T]new(<Args!&&>(args)...);
		= Ptr;
	}

	DESTRUCTOR
	{
		IF(Ptr)
			heap::delete(Ptr);
	}
}