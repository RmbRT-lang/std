(/rl/)

INCLUDE 'std/iterator'
INCLUDE 'std/range'
INCLUDE 'std/index'
INCLUDE 'std/hashable'
INCLUDE 'std/hash'

(// A buffer keeps track of allocated memory but does not own it. /)
::std [T: TYPE] Buffer -> CustomHashable0Cost
{
	Data: T! *;
	Size: UM;

	{};
	{NULL};
	{s: T! *, c: UM}: Data(s), Size(c)
	{
		ASSERT(!Size || Data);
	}
	{BARE} (NULL);

	:buf{s: T! *, c: UM} (s, c);
	[V:TYPE] :array{v: V! &&} := :buf(&v[0], ##v);

	# THIS++ {:buf, T! *, UM} INLINE := :buf(Data, Size);
	# <BOOL> INLINE := Size != 0;

	#? THIS[i: Index #&] T!#?& INLINE := Data[i(Size)];

	# range(
		r: Range #&) [T!]Buffer INLINE
	{
		r(Size);
		= (Data + r.Start, r.Size);
	}

	# drop_start(count: Index) [T!]Buffer
		:= range((count[Size], Size - count[Size]));
	# drop_end(count: Index) [T!]Buffer
		:= range((0, Size - count[Size]));
	# cut(size: Index) [T!]Buffer
		:= range((0, size[Size]));
	# cut_start(size: Index) [T!]Buffer
		:= range((Size-size[Size], size[Size]));

	# ##THIS UM INLINE := Size;

	#? front() T!#?& INLINE := THIS[0];
	#? start() [T!]Buffer#?-[T!#?]Iterator INLINE := (&THIS, 0);

	#? back() T!#?& INLINE:= THIS[Size-1];
	#? end() [T!]Buffer#?-[T!#?]Iterator INLINE := (&THIS, Size-1);

	# empty() BOOL INLINE := !Size;

	# THIS<>(rhs: THIS#&) S1
	{
		IF(s ::= Size <> rhs.Size)
			= s;
		FOR(it ::= start().ok())
			IF(s ::= *it <> rhs[:ok(it())])
				= s;
		= 0;
	}

	# THIS==(rhs: THIS#&) BOOL
	{
		IF(Size != rhs.Size)
			= FALSE;
		FOR(it ::= start().ok())
			IF(*it != rhs[:ok(it())])
				= FALSE;
		= TRUE;
	}

	# hash(h: Hasher &) VOID
	{
		h(##THIS);
		FOR(i ::= start().ok())
			h(*i);
	}
}

::std::range [T: TYPE] destroy_buf(v: [T!]Buffer) VOID INLINE
	:= destroy(v.Data, v.Size);