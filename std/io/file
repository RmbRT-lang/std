(/rl/)

INCLUDE 'std/types'
INCLUDE 'std/io/stream'
INCLUDE 'std/err/filenotfound'
INCLUDE 'std/tags'

::std::io
{
	out: File(libc::stdout);
	in: File(libc::stdin);
	err: File(libc::stderr);

	File
	{
		PRIVATE F: libc::FileHandle \;
		NoCopy;

		{h: libc::FileHandle \}: F(h)
		{
			ASSERT(F);
		}
		write_some_impl(d: VOID #\, s: UM) INLINE UM := libc::fwrite(d, 1, s, F);
		write(d: VOID #\, s: UM) INLINE ::= <<<io::OStream>>>(&THIS).write(:raw(d, s));
		read(d: VOID \, s: UM) INLINE UM := libc::fread(d, 1, s, F);
		read_some(d: VOID \, s: UM) INLINE UM := libc::fread(d, 1, s, F);
		flush() INLINE INT := libc::fflush(F);
		eof() INLINE BOOL := libc::feof(F);
		line(d: CHAR \, s: UM) INLINE CHAR * := libc::fgets(d, s, F);

		STATIC remove(file: CHAR #\) BOOL := 0 == libc::remove(file);

		DESTRUCTOR { libc::fclose(F); }
		{file: CHAR #\, mode: CHAR#\}:
			F(libc::fopen(file, mode))
		{
			IF(!F)
				THROW <FileNotFound>(<std::str::C8CView>(file));
		}

		print(str: CHAR #\) ::= libc::fputs(str, F);
	}
}

::std::io::libc
{
	FileHandle {}
	EXTERN fopen(CHAR#\,CHAR#\) FileHandle *;
	EXTERN fclose(FileHandle *) VOID;
	EXTERN fwrite(VOID#\, UM, UM, FileHandle *) UM;
	EXTERN fread(VOID\, UM, UM, FileHandle *) UM;
	EXTERN feof(FileHandle *) INT;
	EXTERN ferror(FileHandle *) INT;
	EXTERN fflush(FileHandle \) INT;
	EXTERN fputs(CHAR #\, FileHandle \) INT;
	EXTERN fgets(CHAR\, INT, FileHandle \) CHAR *;
	EXTERN remove(CHAR#\) INT;

	EXTERN stdin: FileHandle *;
	EXTERN stdout: FileHandle *;
	EXTERN stderr: FileHandle *;
	EXTERN errno: INT;
}