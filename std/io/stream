(/rl/)

INCLUDE 'std/types'
INCLUDE 'std/str'
INCLUDE 'std/buffer'
INCLUDE 'std/io/streamable'

::std::io
{
	StreamInput
	{
		PRIVATE RawBuffer {
			Data: VOID #*;
			Bytes: UM;
			{};
			{data: VOID#*, bytes: UM} INLINE: Data(data), Bytes(bytes);
		}
		UNION RawBufferOrStreamable
		{
			Buf: RawBuffer;
			Streamable: std::io::Streamable #\;
		}
		IsBuffer: BOOL;
		Value: RawBufferOrStreamable;

		[T: TYPE]
		:buf
		{
			slice: T! #\,
			count: UM
		} INLINE: IsBuffer(TRUE)
		{ Value.Buf := (slice, count * SIZEOF(T)); }

		:raw{
			slice: VOID #\,
			bytes: UM
		} INLINE: IsBuffer(TRUE)
		{ Value.Buf := (slice, bytes); }

		{string: CHAR#\}: IsBuffer(TRUE)
		{ Value.Buf := (string, str::len(string)); }
		:ch{c: CHAR #&} INLINE: IsBuffer(TRUE)
		{ Value.Buf := (&c, 1); }

		:stream{s: Streamable #&}: IsBuffer(FALSE)
		{ Value.Streamable := &s; }
	}

	MASK OStream
	{
		write_some_impl(data: VOID #\, size: UM) UM;

		PRIVATE write_all(i: StreamInput) VOID
		{
			IF(i.IsBuffer)
			{
				d ::= i.Value.Buf;
				p ::= <CHAR#\>(d.Data);
				FOR(left ::= d.Bytes; left > 0;)
				{
					written ::= write_some_impl(p, left);
					left := left - written;
					p := p + written;
				}
			} ELSE
				i.Value.Streamable->stream(THIS);
		}

		[A...: TYPE]
		write(a: A!&&...) VOID
		{
			write_all(<A!&&>(a))...;
		}

		write_some(d: StreamInput) INLINE UM
		{
			ASSERT(d.IsBuffer);
			= write_some_impl(d.Value.Buf.Data, d.Value.Buf.Bytes);
		}
	}

	StreamOutput
	{
		Data: VOID \;
		Bytes: UM;

		[T: TYPE]
		:buf
		{
			slice: T! \,
			count: UM
		} INLINE:
			Data(slice),
			Bytes(count * SIZEOF(T));

		:ch{c: CHAR &} INLINE: Data(&c), Bytes(1);
	}

	MASK IStream
	{
		read_some(data: VOID \, size: UM) UM;

		eof() BOOL;

		[T: TYPE]
		read(data: T! - Buffer #&) INLINE UM
			:= read(data.Data, data.Size);

		read_byte() CHAR
		{
			c: CHAR;
			read_some(&c, 1);
			= c;
		}
	}
}