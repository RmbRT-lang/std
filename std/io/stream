(/rl/)

INCLUDE 'std/interface'
INCLUDE 'std/types'
INCLUDE 'std/memory'
INCLUDE 'std/string'

::std::io
{
	OStream -> [OStream]Interface
	{
		ABSTRACT write_some(VOID #\, UM) UM;

		[T: TYPE] Wrapper -> [OStream]Interface::[T!]Wrapper
		{
			CONSTRUCTOR(v:T!&): [OStream]Interface::[T!]Wrapper(v);

			FINAL write_some(data: VOID #\, size: UM) UM := THIS->impl()->write_some(data, size);
		}
		[T: TYPE] STATIC from(v: T! \) INLINE OStream::[T! \]Wrapper := v;

		write(data: VOID #\, size: UM) UM
		{
			p ::= <char#\>(data);
			FOR(left ::= size; left > 0;)
			{
				written ::= write_some(p, left);
				left := left - written;
				p := p + written;
			}
			RETURN size;
		}

		write_some(str: char #\) UM
			:= write_some(str, str::len(str));
		write(str: char #\) UM
			:= write(str, str::len(str));

		write_some(ch: char) UM
			:= write_some(&ch, 1);
		write(ch: char) UM
			:= write(&ch, 1);

		[T: TYPE]
		write_some(buf: [T!]Buffer #&) INLINE UM
			:= write_some(buf.Data, buf.Size * SIZEOF(T));

		[T: TYPE]
		write(buf: [T!]Buffer #&) INLINE UM
			:= write(buf.Data, buf.Size * SIZEOF(T));
	}

	IStream -> [IStream]Interface
	{
		ABSTRACT read(VOID \, UM) UM;

		[T: TYPE] Wrapper -> [IStream]Interface::[T]Wrapper
		{
			CONSTRUCTOR(v: T#&): [IStream]Interface::[T]Wrapper(v);

			FINAL read(data: VOID \, size: UM) ::= THIS->impl()->read(data, size);
		}
		[T: TYPE] STATIC from(v: T#&) INLINE IStream::[T]Wrapper := v;

		read() char
		{
			c: char;
			read(&c, 1);
			RETURN c;
		}
	}
}