(/rl/)

INCLUDE 'std/types'
INCLUDE 'std/str'

::std::io
{
	::detail StreamInput
	{
		Data: VOID #\;
		Bytes: UM;

		[T: TYPE]
		:buf
		{
			slice: T! #\,
			count: UM
		} INLINE:
			Data(slice),
			Bytes(count * SIZEOF(T));

		:raw{
			slice: VOID #\,
			bytes: UM
		} INLINE:
			Data(slice),
			Bytes(bytes);

		{string: CHAR#\}: Data(string), Bytes(str::len(string));
		:ch{c: CHAR #&} INLINE: Data(&c), Bytes(1);
	}

	MASK OStream
	{
		write_some_impl(data: VOID #\, size: UM) UM;

		PRIVATE write_all(d: detail::StreamInput) UM
		{
			p ::= <CHAR#\>(d.Data);
			FOR(left ::= d.Bytes; left > 0;)
			{
				written ::= write_some_impl(p, left);
				left := left - written;
				p := p + written;
			}
			= d.Bytes;
		}

		[A...: TYPE]
		write(a: A!&&...) UM
		{
			written: UM := 0;
			(written += write_all(<A!&&>(a)))...;
			= written;
		}

		write_some(d: detail::StreamInput) INLINE UM
			:= write_some_impl(d.Data, d.Bytes);
	}

	::detail StreamOutput
	{
		Data: VOID \;
		Bytes: UM;

		[T: TYPE]
		:buf
		{
			slice: T! \,
			count: UM
		} INLINE:
			Data(slice),
			Bytes(count * SIZEOF(T));

		:ch{c: CHAR &} INLINE: Data(&c), Bytes(1);
	}

	MASK IStream
	{
		read_some(data: VOID \, size: UM) UM;

		[T: TYPE]
		read(data: T! - Buffer #&) INLINE UM
			:= read(data.Data, data.Size);

		read_byte() CHAR
		{
			c: CHAR;
			read_some(&c, 1);
			= c;
		}
	}
}