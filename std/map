(/rl/)

INCLUDE 'std/set'

::std [K:TYPE; V:TYPE; Cmp:TYPE] Map
{
	PRIVATE TupleCmp
	{
		[T:TYPE]
		STATIC cmp(a: T!&&, b: {K!,V!}#&) ? := Cmp::cmp(<T!&&>(a), b.(0));
	}

	PRIVATE Set: [{K!,V!}, TupleCmp]VecSet;

	TYPE Location := [{K!,V!}, TupleCmp]VecSet::Location;

	[T: TYPE]
	#? find_loc(k: T! #?&) {V! #?*, Location}
	{
		x ::= Set.find_loc(k);
		IF(x.(0))
			= (&x.(0)->(1), x.(1));
		ELSE
			= (NULL, x.(1));
	}

	[T:TYPE]
	find_loc2(k: T! #&, loc: Location \) V! *
	{
		IF(it ::= Set.find_loc2(k, loc))
			= &it->(1);
		ELSE
			= NULL;
	}

	[T:TYPE]
	#? find_loc2(k: T! #?&, loc: Location \) V! #?*
	{
		IF(it ::= Set.find_loc2(k, loc))
			= &it->(1);
		ELSE
			= NULL;
	}

	[T:TYPE]
	#? find(k: T! #&) V! #?*
	{
		dummy: Location;
		= find_loc2(k, &dummy);
	}

	[Key: TYPE; Value: TYPE]
	insert(k: Key!&&, v: Value!&&) BOOL
	{
		loc: Location;
		IF(find_loc2(k, &loc))
			= FALSE;
		Set.emplace_at(loc, (<Key!&&>(k), <Value!&&>(v)));
		= TRUE;
	}

	[Key: TYPE; Value: TYPE]
	insert_at(loc: Location, k: Key!&&, v: Value!&&) VOID
	{
		Set.emplace_at(loc, (<Key!&&>(k), <Value!&&>(v)));
	}

	[T:TYPE]
	remove(k: T! #&) BOOL INLINE := Set.remove(k);
	[T:TYPE]
	pop(k: T! #&, deleted: V! \) BOOL
	{
		loc: Location;
		IF(it ::= find_loc2(k, &loc))
		{
			*deleted := &&*it;
			Set.remove_at(loc);
			= TRUE;
		}
		= FALSE;
	}

	#? start() ? INLINE := Set.start();
	#? end() ? INLINE := Set.end();
	# empty() BOOL INLINE := Set.empty();

	# ## THIS ? INLINE := ##Set;
}

::std [K:TYPE; V:TYPE] TYPE NatMap := [K!; V!; detail::NaturalCmp]Map;
::std [K:TYPE; V:TYPE; Cmp:TYPE] TYPE DynMap := [K!; V!-std::Dyn; Cmp]Map;
::std [K:TYPE; V:TYPE] TYPE NatDynMap := [K!; V!; detail::NaturalCmp]DynMap;