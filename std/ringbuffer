(/rl/)

INCLUDE 'std/memory'
INCLUDE 'std/iterator'
INCLUDE 'std/string'

::std [T:TYPE] RingBuffer
{
	Data: T! - Buffer[2];

	{};
	{
		d1: T! - Buffer,
		d2: T! - Buffer
	}
	{
		Data[0] := d1;
		Data[1] := d2;
	}

	{
		buf: T! - Buffer
	}
	{
		Data[0] := buf;
	}

	{
		buf: T! - Buffer,
		shift: UM
	}
	{
		Data[0] := buf.drop_start(shift);
		Data[1] := buf.cut(shift);
	}

	# <[T!#]RingBuffer> INLINE := (Data[0], Data[1]);
	# ## THIS INLINE UM := ##Data[0] + ##Data[1];

	# THIS[i: UM] T!#&
	{
		range::check(##THIS, i);
		select ::= i >= ##Data[0];
		i -= select * ##Data[0];
		RETURN Data[select][i];
	}

	THIS[i: UM] T!&
	{
		range::check(##THIS, i);
		select ::= i >= ##Data[0];
		i -= select * ##Data[0];
		RETURN Data[select][i];
	}

	# range(
		start: UM,
		size: UM) T! -RingBuffer
	{
		range::check_subrange(start, size, ##THIS);
		IF(start >= ##Data[0])
			RETURN Data[1].range(start - ##Data[0], size - ##Data[0]);
		ELSE IF(start + size <= ##Data[0])
			RETURN Data[0].range(start, size);
		RETURN (Data[0].drop_start(start), Data[1].cut(start+size - ##Data[0]));
	}

	# drop_start(start: UM) [T!]RingBuffer
		:= range(start, ##THIS - start);
	# drop_end(count: UM) [T!]RingBuffer
		:= range(0, ##THIS - count);
	# cut(size: UM) [T!]RingBuffer
		:= range(0, size);

	start() INLINE [T!]RingBuffer-Iterator := (&THIS, 0);
	# start() INLINE [T!]RingBuffer#-Iterator := (&THIS, 0);
	end() INLINE [T!]RingBuffer-Iterator := (&THIS, ##THIS-1);
	# end() INLINE [T!]RingBuffer#-Iterator := (&THIS, ##THIS-1);

}

::std
{
	[T: TYPE] memcmp(
		lhs: T!# -RingBuffer #&,
		rhs: T! #\,
		elements: UM) SM
	{
		minSz ::= math::min(##lhs, elements);
		FOR(i ::= 0; i<minSz; i++)
			IF(lhs[i] != rhs[i])
				RETURN lhs[i] - rhs[i];
		RETURN ##lhs - elements;
	}

	[T: TYPE] memcmp(
		lhs: T!# -RingBuffer #&,
		rhs: T!# -RingBuffer #&) SM
	{
		minSz ::= math::min(##lhs, ##rhs);
		FOR(i ::= 0; i<minSz; i++)
			IF(lhs[i] != rhs[i])
				RETURN lhs[i] - rhs[i];
		RETURN ##lhs - ##rhs;
	}

	[T: TYPE] memcmp(
		lhs: T!# -RingBuffer #&,
		rhs: T!# -Buffer #&) SM
		:= memcmp(lhs, rhs.Data, rhs.Size);
}

::std::str
{
	[C: TYPE]
	cmp(
		lhs: [C!]RingBuffer#&,
		rhs: [C!]RingBuffer#&) INLINE SM
		:= memcmp(lhs, rhs);
	[C: TYPE]
	cmp(
		lhs: [C!]RingBuffer#&,
		rhs: [C!]Buffer#&) INLINE SM
		:= memcmp(lhs, rhs);

	[C: TYPE]
	starts_with(string: [C!#]RingBuffer #&, find: [C!#]Buffer #&) BOOL
		:= (##find <= ##string) && cmp(string.cut(##find), find) == 0;
	[C: TYPE]
	starts_with(string: [C!#]RingBuffer #&, find: [C!#]RingBuffer #&) BOOL
		:= (##find <= ##string) && cmp(string.cut(##find), find) == 0;

	[C: TYPE]
	starts_with(string: [C!#]RingBuffer #&, find: C! #\) INLINE BOOL
		:= starts_with(string, str::buf(find));
	[C: TYPE]
	starts_with(string: [C!#]Buffer #&, find: [C!#]RingBuffer #&) INLINE BOOL
		:= starts_with((string, NULL), find);
	[C: TYPE]
	starts_with(string: C!#\, find: [C!#]RingBuffer #&) INLINE BOOL
		:= starts_with(str::buf(string), find);
}