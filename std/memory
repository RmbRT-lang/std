(/rl/)

INCLUDE 'std/types'
INCLUDE 'std/range'
INCLUDE 'std/help'
INCLUDE 'std/tags'
INCLUDE 'std/math/limit'

::std
{
	[T: TYPE] memcmp(
		lhs: T! #\,
		rhs: T! #\,
		elements: UM) SM
	{
		FOR(i ::= 0; i<elements; i++)
			IF(lhs[i] != rhs[i])
				RETURN lhs[i] - rhs[i];
		RETURN 0;
	}

	[T: TYPE] memcmp(
		lhs: [T!]Buffer #&,
		rhs: [T!]Buffer #&) SM
	{
		minSz ::= math::min(lhs.Size, rhs.Size);
		IF(sign ::= memcmp(lhs.Data, rhs.Data, minSz))
			RETURN sign;
		ELSE
			RETURN lhs.Size - rhs.Size;
	}

	(// A buffer keeps track of allocated memory but does not own it. /)
	[T: TYPE] Buffer
	{
		Data: T! *;
		Size: UM;

		CONSTRUCTOR(NULL_t): Data(NULL), Size(0);
		CONSTRUCTOR(): Data(NULL), Size(0);
		CONSTRUCTOR(s: T! \, c: UM): Data(s), Size(c);
		CONSTRUCTOR(copy: [T]Buffer#&): Data(copy.Data), Size(copy.Size);

		# end() INLINE T! * := Data + Size;

		# SUBSCRIPT(i: UM) T!#&
		{
			range::check(Size, i);
			RETURN Data[i];
		}
		SUBSCRIPT(i: UM) T!&
		{
			range::check(Size, i);
			RETURN Data[i];
		}

		# range(
			start: UM,
			size: UM) [T!]Buffer
		{
			range::check_subrange(start, size, Size);
			RETURN [T!]Buffer(Data + start, size);
		}

		# drop_start(start: UM) [T!]Buffer
			:= range(start, Size - start);
		# drop_end(count: UM) [T!]Buffer
			:= range(0, Size - count);
		# cut(size: UM) [T!]Buffer
			:= range(0, size);
	}

	[T: TYPE] Dynamic
	{
		NoCopy;

		Ptr: T! *;
		CONSTRUCTOR(): Ptr(NULL);
		CONSTRUCTOR(p: T! *): Ptr(p);
		CONSTRUCTOR(move: [T!]Dynamic &&):
			Ptr(move.Ptr)
		{
			move.Ptr := NULL;
		}

		ASSIGN(p: T! *) [T!]Dynamic & := help::custom_assign(*THIS, p);

		ASSIGN(move: [T!]Dynamic&&) [T!]Dynamic & := help::move_assign(*THIS, move);

		# LOG_NOT() INLINE bool := !Ptr;
		# CONVERT(bool) INLINE NOTYPE! := Ptr;
		# CONVERT(T! \) INLINE NOTYPE! := Ptr;

		DESTRUCTOR
		{
			IF(Ptr)
				::delete(Ptr);
		}
	}

	[T: TYPE] dup(value: T! &&) T! * := ::[T!]new(__cpp_std::move(value));
	[T: TYPE] dup(value: T! #&) T! * := ::[T!]new(value);

	[T: TYPE]
	clone(data: T! #\, size: UM) [T]Buffer
	{
		tmp ::= [T]alloc(size);
		range::copy_construct(tmp.Data, data, size);
		RETURN [T]Buffer(tmp.Data, tmp.Size);
	}
	[T: TYPE]
	clone_move(data: T! #\, size: UM) [T]Buffer
	{
		tmp ::= [T]alloc(size);
		range::move_construct(tmp.Data, data, size);
		RETURN [T]Buffer(tmp.Data, tmp.Size);
	}

	[T: TYPE]
	clone(data: [T!]Buffer#&) [T]Buffer := [T]clone(data.Data, data.Size);


	alloc(bytes: UM) VOID* := detail::libc::malloc(bytes);
	[T: TYPE] alloc() INLINE ::= <T \>(alloc(SIZEOF(T)));
	[T: TYPE] alloc(count: UM) [T]Buffer
		:= [T]Buffer(
			<T \>(detail::libc::malloc(count * SIZEOF(T))),
			count);


	calloc(bytes: UM) VOID* := detail::libc::calloc(bytes, 1);
	[T: TYPE] calloc() T *
	{
		v ::= <T \>(alloc(SIZEOF(T)));
		__rl::CONSTRUCTOR(v);
		RETURN v;
	}
	[T: TYPE] calloc(count: UM) [T]Buffer
	{
		v ::= [T]alloc(count);
		range::default_construct(v, count);
		RETURN v;
	}

	::range [T: TYPE] destroy(v: [T!]Buffer) INLINE VOID
		:= destroy(v.Data, v.Size);

	[T: TYPE] delete(v: [T!]Buffer) INLINE VOID
	{
		range::destroy(v);
		free(v);
	}


	free(mem: VOID#\) VOID  := detail::libc::free(mem);

	[T: TYPE] free(v: [T!]Buffer!#&) INLINE VOID
	{ detail::libc::free(v.Data); }

	[T: TYPE] free(v: T! #\) INLINE VOID
	{ detail::libc::free(v); }
}

::std::detail::libc
{
	EXTERN malloc(ulong) VOID *;
	EXTERN calloc(UM, UM) VOID *;
	EXTERN free(VOID #\) VOID;
	EXTERN realloc(VOID #\, UM) VOID;
}