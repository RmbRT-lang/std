(/rl/)

INCLUDE 'std/types'
INCLUDE 'std/range'
INCLUDE 'std/help'
INCLUDE 'std/tags'

::std
{
	(// A buffer keeps track of allocated memory but does not own it. /)
	[T: TYPE] Buffer
	{
		Data: T! *;
		Size: std::Size;

		CONSTRUCTOR(NULL_t): Data(NULL), Size(0);
		CONSTRUCTOR(): Data(NULL), Size(0);
		CONSTRUCTOR(s: T! \, c: std::Size): Data(s), Size(c);
		CONSTRUCTOR(copy: [T]Buffer#&): Data(copy.Data), Size(copy.Size);

		# end() INLINE T! * := Data + Size;

		# at(i: std::Size) T!#&
		{
			IF(i >= Size)
				THROW;
			RETURN Data[i];
		}
		at(i: std::Size) T!&
		{
			IF(i >= Size)
				THROW;
			RETURN Data[i];
		}
	}

	[T: TYPE] Dynamic
	{
		NoCopy;

		Ptr: T! *;
		CONSTRUCTOR(): Ptr(NULL);
		CONSTRUCTOR(p: T! *): Ptr(p);
		CONSTRUCTOR(move: [T!]Dynamic &&):
			Ptr(move.Ptr)
		{
			move.Ptr := NULL;
		}

		ASSIGN(p: T! *) [T!]Dynamic & := help::custom_assign(*THIS, p);

		ASSIGN(move: [T!]Dynamic&&) [T!]Dynamic & := help::move_assign(*THIS, move);

		DESTRUCTOR
		{
			IF(Ptr)
				::delete(Ptr);
		}
	}

	[T: TYPE] dup(value: T! &&) T! * := ::[T!]new(__cpp_std::move(value));
	[T: TYPE] dup(value: T! #&) T! * := ::[T!]new(value);

	[T: TYPE]
	clone(data: T! #\, size: Size) [T]Buffer
	{
		tmp ::= [T]alloc(size);
		range::copy_construct(tmp.Data, data, size);
		RETURN [T]Buffer(tmp.Data, tmp.Size);
	}
	[T: TYPE]
	clone_move(data: T! #\, size: Size) [T]Buffer
	{
		tmp ::= [T]alloc(size);
		range::move_construct(tmp.Data, data, size);
		RETURN [T]Buffer(tmp.Data, tmp.Size);
	}

	[T: TYPE]
	clone(data: [T!]Buffer#&) [T]Buffer := [T]clone(data.Data, data.Size);


	alloc(bytes: Size) VOID* := detail::libc::malloc(bytes);
	[T: TYPE] alloc() INLINE ::= <T \>(alloc(SIZEOF(T)));
	[T: TYPE] alloc(count: Size) [T]Buffer
		:= [T]Buffer(
			<T \>(detail::libc::malloc(count * SIZEOF(T))),
			count);


	calloc(bytes: Size) VOID* := detail::libc::calloc(bytes, 1);
	[T: TYPE] calloc() T *
	{
		v ::= <T \>(alloc(SIZEOF(T)));
		__rl::CONSTRUCTOR(v);
		RETURN v;
	}
	[T: TYPE] calloc(count: Size) [T]Buffer
	{
		v ::= [T]alloc(count);
		range::default_construct(v, count);
		RETURN v;
	}

	::range [T: TYPE] destroy(v: [T!]Buffer) INLINE VOID
		:= destroy(v.Data, v.Size);

	[T: TYPE] delete(v: [T!]Buffer) INLINE VOID
	{
		range::destroy(v);
		free(v);
	}


	free(mem: VOID#\) VOID  := detail::libc::free(mem);

	[T: TYPE] free(v: [T!]Buffer!#&) INLINE VOID
	{ detail::libc::free(v.Data); }

	[T: TYPE] free(v: T! #\) INLINE VOID
	{ detail::libc::free(v); }
}

::std::detail::libc
{
	EXTERN malloc(ulong) VOID *;
	EXTERN calloc(Size, Size) VOID *;
	EXTERN free(VOID #\) VOID;
	EXTERN realloc(VOID #\, Size) VOID;
}