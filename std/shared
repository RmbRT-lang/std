(/rl/)

INCLUDE 'std/memory'
INCLUDE 'std/dyn'

::std [T: TYPE] Shared
{
	PRIVATE Ptr: T! *;
	PRIVATE Container: detail::SharedAlloc *;

	{}: Container(NULL), Ptr(NULL);
	{BARE} ();
	{NULL}: Container(NULL), Ptr(NULL);
	{&&mv}: Container(mv.Container), Ptr(mv.Ptr) { mv.{}; }

	{#&cpy}: Container(cpy.Container), Ptr(cpy.Ptr)
	{ IF(Container) Container->ref(); }

	:gc{p: T! *}: Ptr(p), Container(NOINIT)
	{
		IF(p)
			Container := heap::[T-detail::SplitAlloc]new(:gc(p));
		ELSE
			Container := NULL;
	}

	:share{v: T!-std::Dyn}:
		Ptr := v.ptr(),
		Container := heap::[T-detail::SplitAlloc]new(:share(&&v))
	{
		ASSERT(Ptr);
	}

	[A...:TYPE]
	:make{a: A!&&...} := :share(:make(<A!&&>(a)...));

	[A...:TYPE]
	:a{a: A!&&...}:
		Container(heap::[T-detail::CompactAlloc]new(<A!&&>(a)...)),
		Ptr(NOINIT)
	{
		Ptr := &<T-detail::CompactAlloc *>(Container)->Value;
	}

	[U:TYPE] :dup{rhs: U!&&}
	{
		alloc: [U-detail::CompactAlloc]Dyn := :a(<U!&&>(rhs));
		Ptr := <<T \>>(&<U-detail::CompactAlloc *>(alloc.ptr())->Value);
		Container := alloc.release();
	}

	[U:TYPE] :<>{rhs: U!-Shared} INLINE
	{
		IF(rhs.ptr())
		{
			Ptr := <<T! \>>(rhs.ptr());
			Container := rhs.container();
			rhs.{};
		}
	}

	// ok
	[U:TYPE] :try{rhs: U!-Shared} INLINE
	{
		IF(rhs)
			IF(Ptr := <<T! *>>(rhs))
			{
				Container := rhs.container();
				rhs.{};
			}
	}

	DESTRUCTOR { IF(Container) Container->deref(); }

	# ptr() T! * INLINE := Ptr;
	# <T! *> INLINE := Ptr;
	# THIS! T! & INLINE := *THIS;
	# *THIS T! & INLINE { ASSERT(Ptr); = *Ptr; }
	# container() detail::SharedAlloc * := Container;
}

::std [T:TYPE] Weak
{
	PRIVATE Container: detail::SharedAlloc *;
	PRIVATE Ptr: T! *;

	{}: Container(NULL), Ptr(NULL);
	{BARE} ();
	{NULL}: Container(NULL), Ptr(NULL);
	{&&mv}: Container(mv.Container), Ptr(mv.Ptr) { mv.{}; }
	
	{#&cpy}: Container(cpy.Container), Ptr(cpy.Ptr)
	{ IF(Container) Container->ref_weak(); }

	:weak{v: [T!]Shared #&}: Container(v.container()), Ptr(v.ptr())
	{
		IF(Container)
			Container->ref_weak();
	}

	[U:TYPE] :<>{rhs: U!-Shared #&} INLINE
	{
		IF(rhs)
		{
			Ptr := <<T! \>>(rhs.ptr());
			Container := rhs.container();
			Container->ref_weak();
		}
	}

	[U:TYPE] :try{rhs: U!-Shared #&} INLINE
	{
		IF(rhs)
			IF(Ptr := <<T! *>>(rhs.ptr()))
			{
				Container := rhs.container();
				Container->ref_weak();
			}
	}

	DESTRUCTOR { IF(Container) Container->deref_weak(); }

	# ptr() T! * INLINE := Container && Container->Refs ?? Ptr : NULL;

	# <T! *> INLINE := ptr();
	# THIS! T! & INLINE := *THIS;
	# *THIS T! & INLINE { p ::= ptr(); ASSERT(p); = p; }
	# container() detail::SharedAlloc * := Container;
}

::std::detail SharedAlloc VIRTUAL
{
	Refs: U2;
	Weaks: U2;

	{}: Refs(1);

	ref() VOID INLINE { ASSERT(++Refs); }
	ref_weak() VOID INLINE { ASSERT(++Weaks); }

	/// Destroys and if possible deallocates the payload.
	PRIVATE ABSTRACT kill_payload() VOID;

	deref() VOID
	{
		ASSERT(Refs);
		IF(!--Refs)
		{
			kill_payload();
			IF(!Weaks)
				heap::delete(&THIS);
		}
	}

	deref_weak() VOID
	{
		ASSERT(Weaks);
		IF(!--Weaks && !Refs)
			heap::delete(&THIS);
	}
}

::std::detail [T:TYPE] CompactAlloc -> SharedAlloc
{
	Value: T;

	[A...:TYPE]{a: A!&&...}: Value(<A!&&>(a)...);

	PRIVATE FINAL kill_payload() VOID { Value := BARE; }
}

::std::detail [T:TYPE] SplitAlloc -> SharedAlloc, PRIVATE [T]Dyn
{
	:gc{ptr: T! \}-> (), (:gc(ptr));
	:share{v: T!-std::Dyn} -> (), (&&v);

	PRIVATE FINAL kill_payload() VOID { <[T]Dyn &>(THIS) := BARE; }
}