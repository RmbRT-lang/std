(/rl/)

INCLUDE 'std/memory'
INCLUDE 'std/dyn'

::std [T: TYPE] Shared
{
	PRIVATE Container: detail::SharedAlloc *;
	PRIVATE Ptr: T! *;

	{}: Container(NULL), Ptr(NULL);
	{BARE} ();
	{NULL}: Container(NULL), Ptr(NULL);
	{&&mv}: Container(mv.Container), Ptr(mv.Ptr) { mv.{}; }
	{#&cpy}: Container(cpy.Container), Ptr(cpy.Ptr) { IF(Container) Container->ref(); }

	:gc{p: T! *}: Ptr(p), Container(NOINIT)
	{
		IF(p)
			Container := heap::[T-detail::SplitAlloc]new(:gc(p));
		ELSE
			Container := NULL;
	}

	[A...:TYPE]
	:a{a: A!&&...}:
		Container(heap::[T-detail::CompactAlloc]new(<A!&&>(a)...)),
		Ptr(NOINIT)
	{
		Ptr := &<T-detail::CompactAlloc *>(Container)->Instance;
	}

	[U:TYPE] :dup{rhs: U!&&}:
		Container(heap::[U-detail::CompactAlloc]new(<U!&&>(rhs))),
		Ptr(NOINIT)
	{
		Ptr := <<T \>>(&<U-detail::CompactAlloc *>(Container)->Instance);
	}

	[U:TYPE] {rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs!)
		{
			Ptr := <<T! \>>(rhs!);
			rhs.{};
		}
		ELSE
			Ptr := NULL;

	}

	[U:TYPE]:try {rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs!)
			IF(Ptr := <<T! *>>(rhs!))
				rhs.{};
			ELSE
				Container := NULL;
		ELSE
			Ptr := NULL;

	}

	DESTRUCTOR { IF(Container) Container->deref(); }

	# <T! *> INLINE := Ptr;
	# THIS! T! * INLINE := Ptr;
	# *THIS T! & INLINE := *Ptr;
	# container() detail::SharedAlloc * := Container;
}

::std [T:TYPE] Weak
{
	PRIVATE Container: detail::SharedAlloc *;
	PRIVATE Ptr: T! *;

	{}: Container(NULL), Ptr(NULL);
	{BARE} ();
	{NULL}: Container(NULL), Ptr(NULL);
	{&&mv}: Container(mv.Container), Ptr(mv.Ptr) { mv.{}; }
	{#&cpy}: Container(cpy.Container), Ptr(cpy.Ptr) { IF(Container) Container->ref_weak(); }

	:weak{v: [T!]Shared #&}: Container(v.container()), Ptr(v!)
	{
		IF(Container)
			Container->ref_weak();
	}

	[U:TYPE] {rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs!)
		{
			Ptr := <<T! \>>(rhs!);
			rhs.{};
		}
		ELSE
			Ptr := NULL;

	}

	[U:TYPE]:try {rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs!)
			IF(Ptr := <<T! *>>(rhs!))
				rhs.{};
			ELSE
				Container := NULL;
		ELSE
			Ptr := NULL;

	}

	DESTRUCTOR { IF(Container) Container->deref_weak(); }

	# ptr() T! * INLINE := Container && Container->Refs ?? Ptr : NULL;

	# <T! *> INLINE := ptr();
	# THIS! T! * INLINE := ptr();
	# *THIS T! & INLINE { IF(Container && Container->Refs) = Ptr; ELSE THROW NULL; }
	# container() detail::SharedAlloc * := Container;	
}

::std::detail SharedAlloc VIRTUAL
{
	Refs: U2;
	Weaks: U2;

	{}: Refs(1);

	ref() VOID INLINE { ASSERT(++Refs); }
	ref_weak() VOID INLINE { ASSERT(++Weaks); }

	/// Destroys and if possible deallocates the payload.
	PRIVATE ABSTRACT kill_payload() VOID;

	deref() VOID 
	{
		ASSERT(Refs);
		IF(!--Refs)
		{
			kill_payload();
			IF(!Weaks)
				heap::delete(&THIS);
		}
	}

	deref_weak() VOID
	{
		IF(!--Weaks && !Refs)
			heap::delete(&THIS);
	}
}

::std::detail [T:TYPE] CompactAlloc -> SharedAlloc
{
	Instance: T;

	[A...:TYPE]{a: A!&&...}: Instance(<A!&&>(a)...);

	PRIVATE FINAL kill_payload() VOID { Instance.~; Instance.{BARE}; }
}

::std::detail [T:TYPE] SplitAlloc -> SharedAlloc, PRIVATE [T]Dyn
{
	:gc{ptr: T! *}-> (), (:gc(ptr));

	PRIVATE FINAL kill_payload() VOID { <[T]Dyn&>(THIS) := NULL; }
}