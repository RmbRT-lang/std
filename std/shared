(/rl/)

INCLUDE 'std/help'
INCLUDE 'std/memory'

::std [T: TYPE] Shared
{
	PRIVATE Container: detail::SharedAlloc *;
	PRIVATE Ptr: T! *;

	{}: Container(NULL), Ptr(NULL);
	{NULL}: Container(NULL), Ptr(NULL);
	{&&mv}: Container(mv.Container), Ptr(mv.Ptr) { mv.{}; }
	{#&cpy}: Container(cpy.Container), Ptr(cpy.Ptr) { IF(Container) Container->ref(); }

	:gc{p: T! *}: Ptr(p)
	{
		IF(p)
			Container := heap::[detail::SharedAlloc]new(p);
		ELSE
			Container := NULL;
	}

	[A...:TYPE]
	:new{a: A!&&...}: Container(alloc_impl()), Ptr(NOINIT)
	{
		Ptr := <T! *>(Container->RealAddr);
		Ptr->{<A!&&>(a)...};
	}

	[U:TYPE] :dup{rhs: U!&&}:
		Container(NOINIT),
		Ptr(heap::[U]new(<U!&&>(rhs)))
	{
		Container := heap::[detail::SharedAlloc]new(Ptr);
	}

	[U:TYPE]{rhs: U!-Shared} INLINE:
		Container(rhs.Container)
	{
		IF(rhs.Ptr)
			Ptr := <<T! \>>(rhs.Ptr);
		ELSE
			Ptr := NULL;

		rhs.{};
	}

	DESTRUCTOR { IF(Container) Container->deref(); }

	# <T! *> INLINE := Ptr;
	# THIS! INLINE T! * := Ptr;
	# *THIS INLINE T! & := *Ptr;

	PRIVATE STATIC alloc_impl() detail::SharedAlloc \
	{
		ret ::= <detail::SharedAlloc \>(
			heap::alloc(
				SIZEOF(detail::SharedAlloc) + SIZEOF(T!)));

		ret->{:compact(detail::SharedAlloc::[T!]dtor_fn)};
		= ret;
	}
}

::std::detail SharedAlloc
{
	RealAddr: VOID *;
	Refs: UM;
	Cleanup: ((VOID *) VOID) \;

	[T:TYPE] STATIC delete_fn(p: VOID *) VOID { heap::[T]delete(<T *>(p)); }
	[T:TYPE] STATIC dtor_fn(p: VOID *) VOID { <T *>(p)->~; }

	:compact{dtor_fn: ((VOID *) VOID) \}:
		RealAddr(<VOID *>(<UM>(&THIS)+SIZEOF(#THIS))),
		Refs(1),
		Cleanup(dtor_fn);

	[T:TYPE] {p: T! *}:
		RealAddr(p),
		Refs(1),
		Cleanup([T]delete_fn);

	ref() INLINE VOID { ++Refs; }

	deref() VOID 
	{
		ASSERT(Refs);

		IF(!--Refs)
		{
			Cleanup(RealAddr);
			heap::delete(&THIS);
		}
	}
}