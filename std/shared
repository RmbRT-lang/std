(/rl/)

INCLUDE 'std/memory'
INCLUDE 'std/dyn'

::std [T: TYPE] Shared
{
	PRIVATE Container: detail::SharedAlloc *;
	PRIVATE Ptr: T! *;

	{}: Container(NULL), Ptr(NULL);
	{NULL}: Container(NULL), Ptr(NULL);
	{&&mv}: Container(mv.Container), Ptr(mv.Ptr) { mv.{}; }
	{#&cpy}: Container(cpy.Container), Ptr(cpy.Ptr) { IF(Container) Container->ref(); }

	:gc{p: T! *}: Ptr(p), Container(NOINIT)
	{
		IF(p)
			Container := heap::[T-detail::SplitAlloc]new(:gc(p));
		ELSE
			Container := NULL;
	}

	[A...:TYPE]
	:new{a: A!&&...}:
		Container(heap::[T-detail::CompactAlloc]new(<A!&&>(a)...)),
		Ptr(NOINIT)
	{
		Ptr := &<T-detail::CompactAlloc *>(Container)->Instance;
	}

	[U:TYPE] :dup{rhs: U!&&}:
		Container(heap::[U-detail::CompactAlloc]new(<U!&&>(rhs))),
		Ptr(NOINIT)
	{
		Ptr := <<T \>>(&<U-detail::CompactAlloc *>(Container)->Instance);
	}

	[U:TYPE]{rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs!)
		{
			Ptr := <<T! \>>(rhs!);
			rhs.{};
		}
		ELSE
			Ptr := NULL;

	}

	[U:TYPE]:try{rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs!)
			IF(Ptr := <<T! *>>(rhs!))
				rhs.{};
			ELSE
				Container := NULL;
		ELSE
			Ptr := NULL;

	}

	DESTRUCTOR { IF(Container) Container->deref(); }

	# <T! *> INLINE := Ptr;
	# THIS! INLINE T! * := Ptr;
	# *THIS INLINE T! & := *Ptr;
	# container() detail::SharedAlloc * := Container;
}

::std::detail SharedAlloc VIRTUAL
{
	Refs: UM;

	{}: Refs(1);

	ref() INLINE VOID { ++Refs; }

	deref() VOID 
	{
		ASSERT(Refs);

		IF(!--Refs)
			heap::delete(&THIS);
	}
}

::std::detail [T:TYPE] CompactAlloc -> SharedAlloc
{
	Instance: T;

	[A...:TYPE]{a: A!&&...}: Instance(<A!&&>(a)...);
}

::std::detail [T:TYPE] SplitAlloc -> SharedAlloc, PRIVATE [T]Dyn
{
	:gc{ptr: T! *}-> (), (:gc(ptr));
}