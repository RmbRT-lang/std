(/rl/)

INCLUDE 'std/memory'
INCLUDE 'std/dyn'

::std [T: TYPE] Shared
{
	PRIVATE Container: detail::SharedAlloc *;
	PRIVATE Ptr: T! *;

	{}: Container(NULL), Ptr(NULL);
	{BARE} ();
	{NULL}: Container(NULL), Ptr(NULL);
	{&&mv}: Container(mv.Container), Ptr(mv.Ptr) { mv.{}; }
	{#&cpy}: Container(cpy.Container), Ptr(cpy.Ptr) { IF(Container) Container->ref(); }

	:gc{p: T! *}: Ptr(p), Container(NOINIT)
	{
		IF(p)
			Container := heap::[T-detail::SplitAlloc]new(:gc(p));
		ELSE
			Container := NULL;
	}

	:share{v: T!-std::Dyn}:
		Ptr := &*v,
		Container := heap::[T-detail::SplitAlloc]new(:share(&&v));

	[A...:TYPE]
	:make{a: A!&&...} := :share(:make(<A!&&>(a)...));

	[A...:TYPE]
	:a{a: A!&&...}:
		Container(heap::[T-detail::CompactAlloc]new(<A!&&>(a)...)),
		Ptr(NOINIT)
	{
		Ptr := &<T-detail::CompactAlloc *>(Container)->Value;
	}

	[U:TYPE] :dup{rhs: U!&&}:
		Container(heap::[U-detail::CompactAlloc]new(<U!&&>(rhs))),
		Ptr(NOINIT)
	{
		Ptr := <<T \>>(&<U-detail::CompactAlloc *>(Container)->Value);
	}

	[U:TYPE] {rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs.ptr())
		{
			Ptr := <<T! \>>(rhs.ptr());
			rhs.{};
		}
		ELSE
			Ptr := NULL;

	}

	[U:TYPE]:try {rhs: U!-Shared} INLINE:
		Container := rhs.container(),
		Ptr (NOINIT)
	{
		IF(rhs)
			IF(Ptr := <<T! *>>(rhs))
				rhs.{};
			ELSE
				Container := NULL;
		ELSE
			Ptr := NULL;

	}

	DESTRUCTOR { IF(Container) Container->deref(); }

	# ptr() T! * INLINE := Ptr;
	# <T! *> INLINE := Ptr;
	# THIS! T! & INLINE := *THIS;
	# *THIS T! & INLINE { ASSERT(Ptr); = *Ptr; }
	# container() detail::SharedAlloc * := Container;
}

::std [T:TYPE] Weak
{
	PRIVATE Container: detail::SharedAlloc *;
	PRIVATE Ptr: T! *;

	{}: Container(NULL), Ptr(NULL);
	{BARE} ();
	{NULL}: Container(NULL), Ptr(NULL);
	{&&mv}: Container(mv.Container), Ptr(mv.Ptr) { mv.{}; }
	{#&cpy}: Container(cpy.Container), Ptr(cpy.Ptr) { IF(Container) Container->ref_weak(); }

	:weak{v: [T!]Shared #&}: Container(v.container()), Ptr(v!)
	{
		IF(Container)
			Container->ref_weak();
	}

	[U:TYPE] {rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs!)
		{
			Ptr := <<T! \>>(rhs!);
			rhs.{};
		}
		ELSE
			Ptr := NULL;
	}

	[U:TYPE]:try {rhs: U!-Shared} INLINE:
		Container(rhs.container()), Ptr(NOINIT)
	{
		IF(rhs!)
			IF(Ptr := <<T! *>>(rhs!))
				rhs.{};
			ELSE
				Container := NULL;
		ELSE
			Ptr := NULL;
	}

	DESTRUCTOR { IF(Container) Container->deref_weak(); }

	# ptr() T! * INLINE := Container && Container->Refs ?? Ptr : NULL;

	# <T! *> INLINE := ptr();
	# THIS! T! & INLINE := *THIS;
	# *THIS T! & INLINE { IF(Container && Container->Refs) = Ptr; ELSE THROW NULL; }
	# container() detail::SharedAlloc * := Container;
}

::std::detail SharedAlloc VIRTUAL
{
	Refs: U2;
	Weaks: U2;

	{}: Refs(1);

	ref() VOID INLINE { ASSERT(++Refs); }
	ref_weak() VOID INLINE { ASSERT(++Weaks); }

	/// Destroys and if possible deallocates the payload.
	PRIVATE ABSTRACT kill_payload() VOID;

	deref() VOID
	{
		ASSERT(Refs);
		IF(!--Refs)
		{
			kill_payload();
			IF(!Weaks)
				heap::delete(&THIS);
		}
	}

	deref_weak() VOID
	{
		ASSERT(Weaks);
		IF(!--Weaks && !Refs)
			heap::delete(&THIS);
	}
}

::std::detail [T:TYPE] CompactAlloc -> SharedAlloc
{
	Value: T;

	[A...:TYPE]{a: A!&&...}: Value(<A!&&>(a)...);

	PRIVATE FINAL kill_payload() VOID { Value := BARE; }
}

::std::detail [T:TYPE] SplitAlloc -> SharedAlloc, PRIVATE [T]Dyn
{
	:gc{ptr: T! \}-> (), (:gc(ptr));
	:share{v: T!-std::Dyn} -> (), (&&v);

	PRIVATE FINAL kill_payload() VOID { <[T]Dyn &>(THIS) := BARE; }
}