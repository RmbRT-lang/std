(/rl/)

::std [V: TYPE]
Iterator
{
	PRIVATE Elems: V! \;
	PRIVATE Current: UM;

	{elems: V! \, start: UM}:
		Elems(elems),
		Current(start);

	# get() & INLINE ::= (*Elems)[Current];
	# THIS! & INLINE ::= (*Elems)[Current];
	# ok() [V!]OkIterator INLINE := (Elems, Current);

	next() VOID
	{
		ASSERT(Current < ##*Elems);
		++Current;
	}

	++THIS [V!]Iterator& INLINE { next(); = THIS; }
	THIS++ [V!]Iterator INLINE { v ::= THIS; next(); = v; }
	--THIS [V!]Iterator& INLINE { prev(); = THIS; }
	THIS-- [V!]Iterator INLINE { v ::= THIS; prev(); = v; }

	# *THIS & INLINE ::= get();

	# THIS+(offset: UM) [V!]Iterator
	{
		ASSERT(Current+offset < ##*Elems);
		= (Elems, Current + offset);
	}

	prev() VOID
	{
		ASSERT(~Current);
		--Current;
	}

	# <BOOL> INLINE := Current < ##*Elems;
}

::std [V: TYPE]
OkIterator
{
	PRIVATE Elems: V! \;
	PRIVATE Current: UM;

	{elems: V! \, start: UM}:
		Elems(elems),
		Current(start);

	# <[V!]Iterator> INLINE := (Elems, Current);

	# get() & ::= (*Elems)[Current];
	# THIS! & ::= (*Elems)[Current];

	next() VOID INLINE
	{ ++Current; }

	++THIS [V!]OkIterator& INLINE { next(); = THIS; }
	THIS++ [V!]OkIterator INLINE { v ::= THIS; next(); = v; }
	--THIS [V!]OkIterator& INLINE { prev(); = THIS; }
	THIS-- [V!]OkIterator INLINE { v ::= THIS; prev(); = v; }

	# *THIS & INLINE ::= get();

	# THIS+(offset: UM) [V!]OkIterator INLINE
		:= (Elems, Current + offset);

	prev() VOID INLINE
	{ --Current; }

	# <BOOL> INLINE := Current < ##*Elems;
}