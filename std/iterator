(/rl/)

::std [T: TYPE; V: TYPE]
Iterator
{
	PRIVATE Elems: V! \;
	PRIVATE Current: UM;

	{elems: V! \, start: UM}:
		Elems(elems),
		Current(start);

	# get() T!& INLINE := (*Elems)[Current];
	# THIS! T!& INLINE := (*Elems)[Current];
	# ok() [T!; V!]OkIterator INLINE := (Elems, Current);

	next() VOID
	{
		ASSERT(Current < ##*Elems);
		++Current;
	}

	++THIS THIS& INLINE { next(); = THIS; }
	THIS++ THIS INLINE { v ::= THIS; next(); = v; }
	--THIS THIS& INLINE { prev(); = THIS; }
	THIS-- THIS INLINE { v ::= THIS; prev(); = v; }

	# *THIS T!& INLINE := get();

	# THIS+(offset: UM) THIS
	{
		ASSERT(Current+offset <= ##*Elems);
		= (Elems, Current + offset);
	}

	prev() VOID
	{
		ASSERT(~Current);
		--Current;
	}

	# <BOOL> INLINE := Current < ##*Elems;
}

::std [T: TYPE; V: TYPE]
OkIterator
{
	PRIVATE Elems: V! \;
	PRIVATE Current: UM;

	{elems: V! \, start: UM}:
		Elems(elems),
		Current(start);

	# <[T!; V!]Iterator> INLINE := (Elems, Current);

	# get() T!& := (*Elems)[Current];
	# THIS! T!& := (*Elems)[Current];

	next() VOID INLINE
	{ ++Current; }

	++THIS THIS& INLINE { next(); = THIS; }
	THIS++ THIS INLINE { v ::= THIS; next(); = v; }
	--THIS THIS& INLINE { prev(); = THIS; }
	THIS-- THIS INLINE { v ::= THIS; prev(); = v; }

	# *THIS T!& INLINE := get();

	# THIS+(offset: UM) THIS INLINE
		:= (Elems, Current + offset);

	prev() VOID INLINE
	{ --Current; }

	# <BOOL> INLINE := Current < ##*Elems;
}