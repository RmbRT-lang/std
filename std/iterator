(/rl/)

::std [V: TYPE]
Iterator
{
	PRIVATE Elems: V! \;
	PRIVATE Current: UM;

	{elems: V! \, start: UM}:
		Elems(elems),
		Current(start);

	# get() INLINE & ::= (*Elems)[Current];
	# THIS! INLINE & ::= (*Elems)[Current];
	# ok() INLINE [V!]OkIterator := (Elems, Current);

	next() VOID
	{
		ASSERT(Current < ##*Elems);
		++Current;
	}

	++THIS INLINE [V!]Iterator& { next(); RETURN THIS; }
	THIS++ INLINE [V!]Iterator { v ::= THIS; next(); RETURN v; }
	--THIS INLINE [V!]Iterator& { prev(); RETURN THIS; }
	THIS-- INLINE [V!]Iterator { v ::= THIS; prev(); RETURN v; }

	# *THIS INLINE & ::= get();

	# THIS+(offset: UM) [V!]Iterator
	{
		ASSERT(Current+offset < ##*Elems);
		RETURN (Elems, Current + offset);
	}

	prev() VOID
	{
		ASSERT(~Current);
		--Current;
	}

	# <BOOL> INLINE := Current < ##*Elems;
}

::std [V: TYPE]
OkIterator
{
	PRIVATE Elems: V! \;
	PRIVATE Current: UM;

	{elems: V! \, start: UM}:
		Elems(elems),
		Current(start);

	# <[V!]Iterator> INLINE := (Elems, Current);

	# get() & ::= (*Elems)[:ok(Current)];
	# THIS! & ::= (*Elems)[:ok(Current)];

	next() INLINE VOID
	{ ++Current; }

	++THIS INLINE [V!]OkIterator& { next(); RETURN THIS; }
	THIS++ INLINE [V!]OkIterator { v ::= THIS; next(); RETURN v; }
	--THIS INLINE [V!]OkIterator& { prev(); RETURN THIS; }
	THIS-- INLINE [V!]OkIterator { v ::= THIS; prev(); RETURN v; }

	# *THIS INLINE & ::= get();

	# THIS+(offset: UM) INLINE [V!]OkIterator
		:= (Elems, Current + offset);

	prev() INLINE VOID
	{ --Current; }

	# <BOOL> INLINE := Current < ##*Elems;
}