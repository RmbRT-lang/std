(/rl/)

INCLUDE 'std/vector'

::std [T: TYPE] MASK Set
{
	(// Queries whether a value is in the set. /)
	# has(key: T! #&) BOOL;

	(// Inserts a value into the set.
	@return
		Whether the value was not in the set yet. /)
	insert(v: T! #&) BOOL;

	(// Inserts a value into the set.
	@return
		Whether the value was not in the set yet. /)
	insert(v: T! &&) BOOL;

	(// Removes a value from the set.
	@return
		Whether the value was in the set. /)
	remove(v: T! #&) BOOL;
}

::std [T: TYPE; Cmp: TYPE] VecSet
{
	PRIVATE Elems: [T!]Vec;

	TYPE Location := UM;

	#? start() INLINE ::= Elems.start();
	#? end() INLINE ::= Elems.end();
	# empty() INLINE BOOL := Elems.empty();

	# ##THIS INLINE UM := ##Elems;

	[V: TYPE]
	# has (v: V! #?&) INLINE BOOL := find(v);

	[V: TYPE]
	#? find(v: V! #?&) T! #? *
	{
		dummy: Location;
		= find_loc2(v, &dummy);
	}

	[V: TYPE]
	#? find_loc(v: V! #?&) { T! #?*, Location }
	{
		loc: Location;
		ret ::= find_loc2(v.(1), &loc);
		= (ret, loc);
	}

	[V: TYPE]
	#? find_loc2(
		v: V! #?&,
		location: Location \
	) T! #? *
	{
		l: UM := 0;
		r: UM := ##Elems;

		i: UM := 0;
		WHILE(l < r)
		{
			i := (l + r)>>1;
			sign ::= Cmp::cmp(v, Elems[i]);
			IF(sign < 0)
				r := i;
			ELSE IF(sign > 0)
				l := i+1;
			ELSE
			{
				*location := i;
				= &Elems[i];
			}
		}

		*location := l;
		= NULL;
	}

	[V: TYPE] insert(v: V!&&) BOOL
	{
		loc: Location;
		IF(find_loc2(v, &loc))
			= FALSE;
		emplace_at(loc, <V!&&>(v));
		= TRUE;
	}

	[A:TYPE]
	THIS+=(v: A!&&) INLINE BOOL
		:= THIS.insert(<A!&&>(v));

	remove_at(
		position: Location) INLINE VOID
	{
		Elems.erase(position);
	}

	[V: TYPE]
	remove(v: V! #&) BOOL
	{
		loc: Location;
		IF(find_loc2(v, &loc))
		{
			remove_at(loc);
			= TRUE;
		}
		= FALSE;
	}

	[V: TYPE]
	THIS-=(v: V! #&) INLINE BOOL := THIS.remove(v);

	[V: TYPE]
	pop(v: V! #&, deleted: T! \) BOOL
	{
		loc: Location;
		IF(it ::= find_loc2(v, &loc))
		{
			*deleted := &&*it;
			remove_at(loc);
			= TRUE;
		}
		= FALSE;
	}


	[A...:TYPE]
	emplace_at(
		position: Location,
		a: A!&&...) T! &
	{
		Elems.emplace_at(position, <A!&&>(a)...);
		= Elems[position];
	}
}

::std::detail NaturalCmp
{
	[A:TYPE; B:TYPE]
	STATIC cmp(a: A!#&, b: B!#&) SM
		:= a == b
			? 0
			: a < b ? -1 : 1;
}

::std [T:TYPE] TYPE NatVecSet := [T!; detail::NaturalCmp]VecSet;