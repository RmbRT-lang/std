(/rl/)

INCLUDE 'std/range'
INCLUDE 'std/memory'
INCLUDE 'std/help'
INCLUDE 'std/types'
INCLUDE 'std/math/limit'
INCLUDE 'std/iterator'

::std [T: TYPE] Vector
{
PRIVATE:
	Content: [T!]Buffer;
	Capacity: UM;
PUBLIC:
	{}: Capacity(0);
	{size: UM}:
		Content([T]alloc(size)),
		Capacity(size)
	{
		range::default_construct(Content.Data, ##Content);
	}
	{copy: [T!]Vector#&}:
		Content(clone(copy.Content)),
		Capacity(##copy);
	{move: [T!]Vector&&}:
		Content(move.Content),
		Capacity(move.Capacity)
	{
		move.Content := NULL;
		move.Capacity := 0;
	}

	{:copy, content: [T#]Buffer #&}:
		Content(clone(content)),
		Capacity(##content);
	{:move, content: [T!]Buffer &&}:
		Content(content),
		Capacity(##content)
	{
		content := NULL;
	}

	[A...:TYPE]
	{:emplace, a: A!&&...}:
		Content(NULL),
		Capacity(0)
	{
		reserve(SIZEOF...(A!));
		_emplace_back(<A!&&>(a)...);
	}

	[A:TYPE; A_...:TYPE]
	PRIVATE _emplace_back(a: A!&&, a_: A_!&&...) INLINE VOID
	{
		THIS += <A!&&>(a);
		_emplace_back(<A_!&&>(a_)...);
	}
	PRIVATE _emplace_back() INLINE VOID {}

	THIS:=(move: [T!]Vector&&) [T!]Vector & := help::move_assign(THIS, move);
	THIS:=(copy: [T!]Vector#&) [T!]Vector & := help::copy_assign(THIS, copy);

	DESTRUCTOR
	{
		IF(Content)
			delete(Content);
	}

	erase(at: UM) VOID
	{
		ASSERT(at < ##THIS);

		THIS![:ok(at)].~;
		--Content.Size;
		range::move_construct(&THIS[:ok(at)], &THIS[:ok(at+1)], ##THIS-at);
	}

	(/
		Reserve the requested amount of space, and leave an uninitialised hole
		in the contents at the requested location. If the hole is within the
		contents, increases the container size to accomodate the hole.
	/)
	PRIVATE reserve_with_hole_at(cap: UM, at: UM) BOOL
	{
		ASSERT(at <= ##Content);
		ASSERT(at <= cap);

		// Is the container already large enough?
		IF(Capacity >= cap)
			// Grow hole if required.
			IF(at < ##Content)
			{
				Content[:ok(##Content)].{&&Content.back(:ok)};
				failed ::= TRUE;
				// Shift contents right.
				TRY
				{
					range::move_assign_r(
						Content.Data+at+1,
						Content.Data+at,
						##Content-at);
					failed := FALSE;
				} FINALLY IF(failed)
				{
					Content.back(:ok) := &&Content[:ok(##Content)];
					Content[:ok(##Content)].~;
				}

				Content[:ok(at)].~; // Destroy hole.
				++Content.Size; // Adjust size.

				RETURN TRUE;
			} ELSE
				RETURN FALSE;

		// Reserve enough space.
		hasHole ::= at != ##Content;
		new ::= [T]alloc(cap).cut(##Content + hasHole);
		range::move_construct(new.Data, Content.Data, at);
		range::move_construct(new.Data+at+1, Content.Data+at, ##Content-at);

		IF(Content.Data)
			delete(Content);
		Content := new;
		Capacity := cap;
		RETURN hasHole;
	}

	(// Reserve space for the requested capacity, without shrinking. /)
	reserve(cap: UM) VOID
	{
		reserve_with_hole_at(cap, ##Content);
	}

	resize(size: UM) VOID
	{
		reserve(size);
		IF(##Content > size)
			range::destroy(Content.drop_start(size));
		ELSE
			range::default_construct(
				&THIS[:ok(##THIS)],
				size - ##Content);
		Content.Size := size;
	}

	(/
		Reserve space for at least one more entry than is currently held.
		Increases ##Content. Leaves an uninitialised hole at the requested
		location.
	/)
	PRIVATE grow_reserve_with_hole_at(at: UM) VOID
	{
		cap: UM;
		IF(!Capacity)
			cap := 1;
		ELSE IF(Capacity > ##THIS)
			cap := Capacity;
		ELSE
			cap := (Capacity+1 + (Capacity >> 4)) | 3;

		// Increase content if appending.
		Content.Size += !reserve_with_hole_at(cap, at);
	}

	[A...:TYPE]
	emplace(at: UM, a: A!&&...) INLINE VOID
	{
		grow_reserve_with_hole_at(at);
		failed ::= TRUE;
		TRY
		{
			THIS[:ok(at)].{<A!&&>(a)...};
			failed := FALSE;
		} FINALLY IF(failed)
		{
			IF(at != ##THIS-1)
			{
				THIS[:ok(at)].{&&THIS[:ok(at+1)]};
				range::move_assign(&THIS[:ok(at+1)], &THIS[:ok(at+2)], ##THIS-(at+2));
				THIS!.back(:ok).~;
			}
			Content.Size--;
		}
	}

	[A:TYPE]
	THIS+=(a: A!&&) VOID
	{
		emplace(##THIS, <A!&&>(a));
	}

	[A:TYPE]
	THIS+=(at: {{:at, UM}, A!&&}) VOID
	{ emplace(at.(1), <A!&&>(at.(2))); }

	[A:TYPE]
	THIS+=(at: {{:at, :back}, A!&&}) VOID
	{ emplace(##THIS, <A!&&>(at.(2))); }

	[A:TYPE]
	THIS+=(at: {{:at, :front}, A!&&}) VOID
	{ emplace(0, <A!&&>(at.(2))); }

	THIS[i: UM] INLINE T!& := Content[i];
	THIS[i: {:ok, UM}] INLINE T!& := Content[i];
	# THIS[i: UM] INLINE T!#& := Content[i];
	# THIS[i: {:ok, UM}] INLINE T!#& := Content[i];

	# <BOOL> := Content.Size;

	# ##THIS INLINE UM := Content.Size;
	# data() INLINE T! #* := Content.Data;
	# empty() INLINE BOOL := ##THIS == 0;

	THIS! INLINE ::= Content;
	# THIS! INLINE #& ::= Content;

	start() INLINE [T!]Vector-Iterator := (&THIS, 0);
	# start() INLINE [T!]Vector#-Iterator := (&THIS, 0);
	end() INLINE [T!]Vector-Iterator := (&THIS, ##THIS-1);
	# end() INLINE [T!]Vector#-Iterator := (&THIS, ##THIS-1);

	[TCmp:TYPE]
	Cmp
	{
		STATIC cmp(a: [T!]Vector#&, b:[T!]Vector#&) SM
		{
			len # ::= math::min(##a, ##b);
			FOR(i ::= 0; i < len; i++)
			{
				sign ::= TCmp::cmp(a, b);
				IF(sign) RETURN sign;
			}
			IF(##a == ##b)
				RETURN 0;
			RETURN ##a > ##b ? 1 : -1;
		}
	}
}

::std [T:TYPE] TYPE DynVector := T! - Dynamic - Vector;