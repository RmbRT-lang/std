(/rl/)

INCLUDE 'std/range'
INCLUDE 'std/memory'
INCLUDE 'std/help'

::std [T: TYPE] Vector
{
PRIVATE:
	Content: [T!]Buffer;
PUBLIC:
	CONSTRUCTOR();
	CONSTRUCTOR(size: size_t):
		Content([T]alloc(size))
	{
		FOR(i ::= 0; i < Content.Size; i++)
			__rl::CONSTRUCTOR(Content.Data[i]);
	}
	CONSTRUCTOR(copy: [T!]Vector#&):
		Content(clone(copy.Content));
	CONSTRUCTOR(move: [T!]Vector&&):
		Content(move.Content)
	{
		move.Content := NULL;
	}

	ASSIGN(move: [T!]Vector&&) [T!]Vector & := std::help::move_assign(*THIS, move);

	DESTRUCTOR
	{
		FOR(i ::= 0; i < Content.Size; i++)
			__rl::DESTRUCTOR(Content.Data[i]);

		IF(Content.Size)
			free(Content);
	}

	push_back(v: T #&) VOID
	{
		new ::= [T]alloc(Content.Size+1);
		range::move_construct(new.Data, Content.Data, Content.Size);
		IF(Content.Size)
			delete(Content);
		Content := new;
		__rl::CONSTRUCTOR(Content.Data[Content.Size-1], v);
	}

	push_back(v: T &&) VOID
	{
		new ::= [T]alloc(Content.Size+1);
		range::move_construct(new.Data, Content.Data, Content.Size);
		IF(Content.Size)
			delete(Content);
		Content := new;
		__rl::CONSTRUCTOR(Content.Data[Content.Size-1], __cpp_std::move(v));
	}

	at(i: Size) INLINE ::= Content.at(i);
	# at(i: Size) INLINE ::= Content.at(i);
	# size() INLINE Size := Content.Size;
	# empty() INLINE bool := size() == 0;
}