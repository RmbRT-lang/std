(/rl/)

INCLUDE 'std/range'
INCLUDE 'std/memory'
INCLUDE 'std/help'
INCLUDE 'std/pass'
INCLUDE 'std/types'

::std [T: TYPE] Vector
{
PRIVATE:
	Content: [T!]Buffer;
PUBLIC:
	CONSTRUCTOR();
	CONSTRUCTOR(size: UM):
		Content([T]alloc(size))
	{
		FOR(i ::= 0; i < Content.Size; i++)
			__rl::CONSTRUCTOR(Content.Data[i]);
	}
	CONSTRUCTOR(copy: [T!]Vector#&):
		Content(clone(copy.Content));
	CONSTRUCTOR(move: [T!]Vector&&):
		Content(move.Content)
	{
		move.Content := NULL;
	}

	CONSTRUCTOR(pass::Copy, content: [T#]Buffer #&):
		Content(clone(content));
	CONSTRUCTOR(pass::Move, content: [T#]Buffer #&):
		Content(content);

	ASSIGN(move: [T!]Vector&&) [T!]Vector & := std::help::move_assign(*THIS, move);

	DESTRUCTOR
	{
		FOR(i ::= 0; i < Content.Size; i++)
			__rl::DESTRUCTOR(Content.Data[i]);

		IF(Content.Size)
			free(Content);
	}

	push_back(v: T #&) VOID
	{
		emplace_back(v);
	}

	push_back(v: T &&) VOID
	{
		emplace_back(__cpp_std::move(v));
	}

	[A:TYPE]
	emplace_back(a: A!&&) VOID
	{
		new ::= [T]alloc(Content.Size+1);
		range::move_construct(new.Data, Content.Data, Content.Size);
		IF(Content.Size)
			delete(Content);
		Content := new;
		__rl::CONSTRUCTOR(
			Content.Data[Content.Size-1],
			__cpp_std::[A!]forward(a));
	}

	[A:TYPE,B:TYPE]
	emplace_back(a: A!&&, b: B!&&) VOID
	{
		new ::= [T]alloc(Content.Size+1);
		range::move_construct(new.Data, Content.Data, Content.Size);
		IF(Content.Size)
			delete(Content);
		Content := new;
		__rl::CONSTRUCTOR(
			Content.Data[Content.Size-1],
			__cpp_std::[A!]forward(a),
			__cpp_std::[B!]forward(b));
	}

	SUBSCRIPT(i: UM) INLINE ::= Content[i];
	# SUBSCRIPT(i: UM) INLINE ::= Content[i];
	# size() INLINE UM := Content.Size;
	# empty() INLINE bool := size() == 0;

	# range(start: UM, length: UM) [T!#]Buffer
		:= Content.range(start, length);
	range(start: UM, length: UM) [T!]Buffer
		:= Content.range(start, length);
}