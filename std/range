
(/rl/)

INCLUDE 'std/math/safe'
INCLUDE 'std/err/indexoutofrange'

(// A sub-range within an integer-indexed collection. /)
::std Range
{
	Start: UM;
	Size: UM;
	Checked: BOOL;

	{};

	{
		start: UM,
		size: UM
	} INLINE :
		Start(start),
		Size(size),
		Checked(FALSE);
	
	:ok{
		start: UM,
		size: UM
	} INLINE :
		Start(start),
		Size(size),
		Checked(TRUE);

	/// Throws if the range is outside the supplied bounds.
	# THIS(bounds: UM) VOID INLINE
	{
		IF(!Checked)
			IF(math::safe::add(Start, Size) > bounds)
				THROW <std::err::IndexOutOfRange>(bounds, Start+Size);
	}
}

::std::range
{
	[T: TYPE] copy_assign(
		dst: T! \,
		src: T!# \,
		count: UM) VOID
	{
		FOR(i ::= 0; i<count; i++)
			dst[i] := src[i];
	}

	[T: TYPE] move_assign(
		dst: T! \,
		src: T! \,
		count: UM) VOID
	{
		FOR(i ::= 0; i < count; i++)
			dst[i] := &&src[i];
	}

	[T: TYPE] default_construct(
		range: T! \,
		count: UM) VOID
	{
		i: UM;
		TRY FOR(i := 0; i<count; i++)
			range[i].{};
		FINALLY IF(i != count)
			destroy(range, i);
	}


	[T: TYPE] copy_construct(
		dst: T! \,
		src: T!# \,
		count: UM) UM
	{
		i: UM;
		TRY FOR(i := 0; i<count; i++)
			dst[i].{src[i]};
		FINALLY IF(i != count)
			destroy(dst, i);
		= count;
	}

	[T: TYPE] move_construct(
		dst: T! \,
		src: T! \,
		count: UM) VOID
	{
		i: UM;
		TRY FOR(i := 0; i<count; i++)
			dst[i].{&&src[i]};
		FINALLY IF(i != count)
			destroy(dst, i);
	}

	[T: TYPE] move_assign_r(
		dst: T! \,
		src: T! \,
		count: UM) VOID
	{
		FOR(i ::= count; i--;)
			dst[i] := &&src[i];
	}

	[T: TYPE] destroy(
		range: T! \,
		count: UM) VOID INLINE
	{
		FOR(i ::= 0; i<count; i++)
			range[i].~;
	}

	[T: TYPE; N: NUMBER] ArrayIter
	{
		Range: T! \;
		Index: UM;

		{array: T![N] &, index: UM}: Range(&array[0]), Index(index);

		# <BOOL> INLINE := Index < N;
		# THIS! T!& INLINE := *THIS;
		# *THIS T!& INLINE := Range[Index];

		THIS++ [T!; #N]ArrayIter INLINE { t ::= THIS; ++Index; = t; }
		++THIS [T!; #N]ArrayIter& INLINE { ++Index; = THIS; }
		THIS-- [T!; #N]ArrayIter INLINE { t ::= THIS; --Index; = t; }
		--THIS [T!; #N]ArrayIter& INLINE { --Index; = THIS; }
	}

	[T: TYPE; N: NUMBER] start(range: T![N] &) ? := [T!; #N]ArrayIter(range, 0);
	[T: TYPE; N: NUMBER] end(range: T![N] &) ? := [T!; #N]ArrayIter(range, N-1);
}