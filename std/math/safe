(/rl/)

INCLUDE 'std/error'
INCLUDE 'std/io/streamutil'

::std::math Overflow -> Error
{
	# OVERRIDE stream(o: io::OStream &) VOID
	{
		io::write(o, "overflow/underflow");
	}
}

::std::math ZeroDiv -> Error
{
	# OVERRIDE stream(o: io::OStream &) VOID
		:= io::write(o, "division by 0");
}

::std::math::safe
{
	[T:TYPE] addc(lhs: T! #&, rhs: T! #&, carry: BOOL &) T INLINE
	{
		ret: T := <UM>(lhs) + <UM>(rhs);
		carry := <UM>(ret) < lhs;
		= ret;
	}

	[T:TYPE] add(lhs: T! #&, rhs: T! #&) T INLINE
	{
		carry: BOOL;
		ret ::= addc(lhs, rhs, carry);
		IF(carry)
			THROW <Overflow>();
		= ret;
	}

	[T: TYPE] mulc(lhs: T! #&, rhs: T! #&, carry: BOOL &) T INLINE
	{
		carry := rhs && <UM>(lhs) > <UM>(~<T>(0)) / <UM>(rhs);
		= <UM>(lhs) * <UM>(rhs);
	}

	[T: TYPE] mul(lhs: T! #&, rhs: T! #&) T INLINE
	{
		carry: BOOL;
		ret ::= mulc(lhs, rhs, carry);
		IF(carry)
			THROW <Overflow>();
		= ret;
	}

	[T: TYPE] neg(x: T! #&) T INLINE
	{
		IF(<T>(<UM>(x) << 1) == 0)
			THROW <Overflow>();
		= -x;
	}

	[T:TYPE]
	Int
	{
		PRIVATE V: T;

		{};
		{v: T #&}: V(v);
		{v: T &&}: V(v);

		# -THIS THIS := neg(V);
		# +THIS THIS #& := THIS;

		# THIS+(rhs: T#&) THIS := add(V, rhs);
		# THIS-(rhs: T#&) THIS := sub(V, rhs);
		# THIS*(rhs: T#&) THIS := mul(V, rhs);
		# THIS/(rhs: T#&) THIS := div(V, rhs);
		# THIS%(rhs: T#&) THIS := mod(V, rhs);

		THIS+=(rhs: T#&) THIS& := THIS := THIS + rhs;
		THIS-=(rhs: T#&) THIS& := THIS := THIS - rhs;
		THIS*=(rhs: T#&) THIS& := THIS := THIS * rhs;
		THIS/=(rhs: T#&) THIS& := THIS := THIS / rhs;
		THIS%=(rhs: T#&) THIS& := THIS := THIS % rhs;

		# <T #&> INLINE := V;
	}
}