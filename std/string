(/rl/)

INCLUDE 'std/memory'
INCLUDE 'std/help'
INCLUDE 'std/transfer'

::std
{
	::helper CString {}
	cstring: helper::CString#;

	[C: TYPE]
	strbuf(str: C! \) [C!]Buffer!
		:= [C!]Buffer(str, strlen(str));

	[C: TYPE]
	strlen(str: C! #\) Size
	{
		i: Size := 0;
		WHILE(str[i]) ++i;
		RETURN i;
	}

	[C: TYPE]
	strcmp(
		lhs: [C!]Buffer#&,
		rhs: [C!]Buffer#&) SSize
	{
		minSz #::= lhs.Size > rhs.Size ? rhs.Size : lhs.Size;

		FOR(i:Size := 0; i < minSz; i++)
			IF(lhs.Data[i] != rhs.Data[i])
				RETURN lhs.Data[i] - rhs.Data[i];

		RETURN (lhs.Size - rhs.Size);
	}

	[C: TYPE]
	String
	{
		PRIVATE Content: [C!]Buffer;

		CONSTRUCTOR() {}
		CONSTRUCTOR(str: C #\, helper::CString):
			Content(clone(str, strlen(str)+1))
		{
			// Remove the terminating 0-byte from the content.
			Content.Size--;
		}

		CONSTRUCTOR(data: [C#]Buffer #&): Content(clone(data));
		CONSTRUCTOR(data: [C!]Buffer #&, Transfer): Content(data);

		CONSTRUCTOR(str: C #\):
			Content(clone(str, strlen(str)));
		CONSTRUCTOR(
			cpy: [C]String #&):
			Content(clone(cpy.Content));
		CONSTRUCTOR(
			mv: [C]String &&):
			Content(mv.Content)
		{
			mv.Content := NULL;
		}
		DESTRUCTOR
		{
			IF(Content.Data)
				free(Content);
		}

		ASSIGN(rhs: [C!]String#&) [C!]String& := help::copy_assign(*THIS, rhs);
		ASSIGN(rhs: [C!]String&&) [C!]String& := help::move_assign(*THIS, rhs);

		# data() INLINE ::= Content.Data;
		# size() INLINE ::= Content.Size ? Content.Size: 0;
		# content() INLINE [C!#]Buffer := Content;
		content() INLINE ::= Content;
		# at(i: Index) ::= Content.at(i);

		append(str: [C#]Buffer #&) VOID
			:= append(str.Data, str.Size);
		append(str: C #\, size: Size) VOID
		{
			new ::= [C]alloc(Content.Size + size);
			range::copy_construct(new.Data, Content.Data, Content.Size);
			range::copy_construct(new.Data+Content.Size, str, size);
			DESTRUCTOR();
			CONSTRUCTOR(new, std::transfer);
		}

		append(str: C #\) VOID := append(strbuf(str));

		# substring(start: Index, size: Size) [C!#]Buffer
		{
			IF(start + size > Content.Size)
				THROW;

			RETURN [C!#]Buffer(Content.Data + start, size);
		}

		substring(start: Index, size: Size) [C!]Buffer
		{
			IF(start + size > Content.Size)
				THROW;

			RETURN [C!]Buffer(Content.Data + start, size);
		}

		# cmp(rhs: [C!]String #&) SSize := strcmp(content(), rhs.content());
	}

	TYPE Utf8 := [char]String;
}