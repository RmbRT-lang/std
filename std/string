(/rl/)

INCLUDE 'std/memory'
INCLUDE 'std/help'
INCLUDE 'std/transfer'

::std
{
	::helper CString {}
	cstring: helper::CString#;


	::str
	{
		[C: TYPE]
		buf(str: C! \) [C!]Buffer
			:= [C!]Buffer(str, len(str));

		[C: TYPE]
		len(str: C! #*) UM
		{
			IF(!str)
				RETURN 0;
			i: UM := 0;
			WHILE(str[i]) ++i;
			RETURN i;
		}

		[C: TYPE]
		cmp(
			lhs: [C!]Buffer#&,
			rhs: [C!]Buffer#&) SM
		{
			minSz #::= lhs.Size > rhs.Size ? rhs.Size : lhs.Size;

			FOR(i:UM := 0; i < minSz; i++)
				IF(lhs.Data[i] != rhs.Data[i])
					RETURN lhs.Data[i] - rhs.Data[i];

			RETURN (lhs.Size - rhs.Size);
		}

		[C: TYPE]
		starts_with(string: [C!#]Buffer #&, find: [C!#]Buffer #&) bool
		{
			IF(find.Size > string.Size)
				RETURN FALSE;
			RETURN memcmp(string.Data, find.Data, find.Size) == 0;
		}

		[C: TYPE]
		starts_with(string: [C!#]Buffer #&, find: C! #\) INLINE bool
			:= starts_with(string, buf(find));
	}

	[C: TYPE]
	String
	{
		PRIVATE Content: [C!]Buffer;

		CONSTRUCTOR() {}
		CONSTRUCTOR(str: C #\, helper::CString):
			Content(clone(str, str::len(str)+1))
		{
			// Remove the terminating 0-byte from the content.
			Content.Size--;
		}

		CONSTRUCTOR(data: [C#]Buffer #&): Content(clone(data));
		CONSTRUCTOR(data: [C!]Buffer #&, Transfer): Content(data);

		CONSTRUCTOR(str: C #\):
			Content(clone(str, str::len(str)));
		CONSTRUCTOR(
			cpy: [C]String #&):
			Content(clone(cpy.Content));
		CONSTRUCTOR(
			mv: [C]String &&):
			Content(mv.Content)
		{
			mv.Content := NULL;
		}
		DESTRUCTOR
		{
			IF(Content.Data)
				free(Content);
		}

		ASSIGN(rhs: [C!]String#&) [C!]String& := help::copy_assign(*THIS, rhs);
		ASSIGN(rhs: [C!]String&&) [C!]String& := help::move_assign(*THIS, rhs);

		# data() INLINE ::= Content.Data;
		# size() INLINE ::= Content.Size ? Content.Size: 0;
		# content() INLINE [C!#]Buffer := Content;
		content() INLINE ::= Content;
		# SUBSCRIPT(i: UM) ::= Content[i];

		append(str: [C#]Buffer #&) VOID
			:= append(str.Data, str.Size);
		append(str: C #\, size: UM) VOID
		{
			new ::= [C]alloc(Content.Size + size);
			range::copy_construct(new.Data, Content.Data, Content.Size);
			range::copy_construct(new.Data+Content.Size, str, size);
			DESTRUCTOR();
			CONSTRUCTOR(new, std::transfer);
		}

		append(str: C #\) VOID := append(str::buf(str));
		append(str: C) INLINE VOID := append(&str, 1);

		# substring(start: UM, size: UM) [C!#]Buffer
			:= Content.range(start, size);

		substring(start: UM, size: UM) [C!]Buffer
			:= Content.range(start, size);

		# cmp(rhs: [C!]String #&) SM := str::cmp(content(), rhs.content());

		# starts_with(str: C #\) INLINE
			::= str::starts_with(<[C#]Buffer>(Content), str);
		# starts_with(str: [C#]Buffer #&) INLINE
			::= str::starts_with(<[C#]Buffer>(Content), str);
	}

	TYPE Utf8 := [char]String;
	TYPE Utf32 := [C32]String;
}