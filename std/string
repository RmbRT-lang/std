(/rl/)

INCLUDE 'std/memory'

INCLUDE 'std/str'

/// Dynamic container for an std::str::View.
::std [C: TYPE] String
{
	PRIVATE Content: [C!]Buffer;

	{};
	{BARE} ();

	{data: str::[C#]View #&}: Content(heap::clone(data));
	:cstring{data: str::[C#]View #&}: Content(heap::[C]alloc(##data+1))
	{
		range::copy_construct(Content.Data, data.Data, ##data);
		Content.Data[--Content.Size] := 0;
	}
	:transfer{data: [C!]Buffer #&}: Content(data);

	{#&cpy}:
		Content(heap::clone(cpy.Content));
	{&&mv}:
		Content(mv.Content)
	{
		mv.Content := NULL;
	}
	DESTRUCTOR
	{
		IF(Content)
			heap::free(Content);
		Content := NULL;
	}

	Cmp
	{
		STATIC cmp(lhs: C!-String#&, rhs: C!-String#&) SM := lhs!.cmp(rhs!);
	}

	# data() ? INLINE := Content.Data;
	# ##THIS ? INLINE := ##Content;
	# THIS[i: Index #&] ?#& INLINE := Content[i];
	# THIS! str::[C#]View INLINE := Content++;

	[T...: TYPE]
	append(v: T!&&...) VOID INLINE
	{ append_impl(<str::[C#]View>(<T!&&>(v))...); }
	[T...: TYPE]
	PRIVATE append_impl(v: T!&&...) VOID {
		sz: UM := ##THIS;
		(sz += ##v)...;

		new ::= heap::[C]alloc(sz);
		start ::= new.Data;
		start += range::copy_construct(start, Content.Data, ##Content);
		(start += range::copy_construct(start, v.Data, ##v))...;
		THIS := :transfer(new);
	}

	THIS+=(str: str::[C#]View #&) VOID INLINE
	{ append(str); }
}

::std
{
	TYPE Str := [CHAR]String;
	TYPE Str2 := [U2]String;
	TYPE Str4 := [U4]String;
}