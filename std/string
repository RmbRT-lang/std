(/rl/)

INCLUDE 'std/memory'

INCLUDE 'std/str'

::std [C: TYPE]
String
{
	PRIVATE Content: [C!]Buffer;

	{} {}

	{data: str::[C#]View #&}: Content(heap::clone(data));
	:transfer{data: [C!]Buffer #&}: Content(data);

	{#&cpy}:
		Content(heap::clone(cpy.Content));
	{&&mv}:
		Content(mv.Content)
	{
		mv.Content := NULL;
	}
	DESTRUCTOR
	{
		IF(Content)
			heap::free(Content);
		Content := NULL;
	}

	# data() INLINE ::= Content.Data;
	# ##THIS INLINE ::= ##Content;
	# THIS[i: Index #&] INLINE #& ::= Content[i];
	# THIS! INLINE str::[C#]View := Content++;

	[T...: TYPE]
	append(v: T!&&...) INLINE VOID
	{ append_impl(<str::[C#]View>(<T!&&>(v))...); }
	[T...: TYPE]
	PRIVATE append_impl(v: T!&&...) VOID {
		sz: UM := ##THIS;
		(sz += ##v)...;

		new ::= heap::[C]alloc(sz);
		start ::= new.Data;
		start += range::copy_construct(start, Content.Data, ##Content);
		(start += range::copy_construct(start, v.Data, ##v))...;
		THIS := :transfer(new);
	}

	THIS+=(str: str::[C#]View #&) INLINE VOID
	{ append(str); }
}

::std
{
	TYPE Str := [CHAR]String;
	TYPE Str2 := [U2]String;
	TYPE Str4 := [U4]String;
}