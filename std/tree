(/rl/)

INCLUDE 'std/memory'

::std [T: TYPE, Cmp: TYPE] BinaryTree
{
	TYPE Node := detail::binary_tree::[T]Node;
	TYPE Location := detail::binary_tree::[T]Location;

	Root: [Node]Dynamic;

	[N:TYPE, V: TYPE]
	PRIVATE IteratorBase
	{
		PRIVATE Current: N! *;

		CONSTRUCTOR(start: N! *):
			Current(start);

		get() V! * := Current;
		# get() V! # * := Current;

		next() VOID
		{
			IF(!Current)
				RETURN;

			IF(Current->Right)
			{
				Current := Current->Right.Ptr;
				descend();
			} ELSE
			{
				Current := Current->Parent;
			}
		}

		PRIVATE descend() VOID
		{
			IF(!Current)
				RETURN;

			WHILE(Current->Left.Ptr)
				Current := Current->Left.Ptr;
		}
	}

	TYPE Iterator := [Node, T!]IteratorBase;
	TYPE ConstIterator := [Node!#, T!#]IteratorBase;

	range() INLINE ::= [T!, Cmp!]BinaryTree::Iterator(THIS->Root.Ptr);
	# range() INLINE ::= [T!, Cmp!]BinaryTree::ConstIterator(THIS->Root.Ptr);

	# empty() INLINE bool := Root.Ptr == NULL;

	[V: TYPE]
	# find(
		v: V! #&
	) T! # *
	{
		dummy: Location;
		RETURN find(&dummy);
	}

	[V: TYPE]
	find(
		v: V! #&
	) T! *
	{
		dummy: Location;
		RETURN find(&dummy);
	}

	[V: TYPE]
	# find(
		v: V! #&,
		location: detail::binary_tree::[T]Location \
	) T! # *
	{
		location->Parent := NULL;
		FOR(p ::= Root.Ptr; p;)
		{
			location->Parent := p;
			sign ::= Cmp::cmp(v, p->Value);
			IF(sign == 0)
				RETURN &p->Value;
			ELSE IF(sign < 0)
				p := p->Left.Ptr;
			ELSE
				p := p->Right.Ptr;
		}

		RETURN NULL;
	}

	[V: TYPE]
	find(
		v: V! #&,
		location: detail::binary_tree::[T]Location \
	) T! *
	{
		location->Parent := NULL;
		FOR(p ::= Root.Ptr; p;)
		{
			location->Parent := p;
			sign ::= Cmp::cmp(v, p->Value);
			IF(sign == 0)
				RETURN &p->Value;
			ELSE IF(sign < 0)
				p := p->Left.Ptr;
			ELSE
				p := p->Right.Ptr;
		}

		RETURN NULL;
	}

	insert_at(
		position: Location #&,
		v: T!#&) T! *
	{
		node ::= ::[Node]new(v);
		IF(position.Parent == NULL)
			Root := node;
		ELSE IF(!position.Side)
			position.Parent->Left := node;
		ELSE
			position.Parent->Right := node;
		RETURN &node->Value;
	}

	insert_at(
		position: Location #&) T! *
	{
		node ::= ::[Node]new();
		IF(position.Parent == NULL)
			Root := node;
		ELSE IF(!position.Side)
			position.Parent->Left := node;
		ELSE
			position.Parent->Right := node;
		RETURN &node->Value;
	}
}

::std::detail::binary_tree [T: TYPE] Node
{
	CONSTRUCTOR();
	CONSTRUCTOR(v: T#&): Value(v);
	CONSTRUCTOR(v: T&&): Value(__cpp_std::move(v));

	Value: T;
	Left: [Node]Dynamic;
	Right: [Node]Dynamic;
	Parent: Node *;
}

::std::detail::binary_tree [T: TYPE] Location
{
	Parent: [T]Node *;
	Side: bool;
}